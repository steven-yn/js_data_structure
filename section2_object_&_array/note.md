# 객체

- 객체의 특징

1. 정렬되지 않은 데이터 구조
2. 모두 key value 짝을 갖고 저장
3. 정렬이 필요없을때 잘 작동함
4. 빠른 접근,입력,제거 를 원할때 좋음

빠르다는것은 접근,입력,제거 등이 모두 상수시간임을 뜻함

추가 ( insertion ) - O(1)
제거 ( removal ) - O(1)
탐색 ( searching ) - O(N)
접근 ( access ) - O(1)

Object.keys - O(N)
Object.values - O(N)
Object.entries - O(N)
hasOwnProperty - O(1)

# 배열

- 배열의 특징

1. 정렬이 되어 있음. 데이터가 정렬되어 있는 기준이 있다.
2. 객체에 비해 연산하는 시간이 더 걸릴수 있다.

정렬할 필요가 없다면, 배열을 사용하지 않는것이 좋다.
정렬 되어 있는것이 필요하더라도, 단방향 연결 리스트와 양방향 연결 리스트 처럼
코드안에 정렬된 구조가 있는 데이터도 있다.
때로는 하는작업에 따라 배열보다 더 빠를수 있다.
중요한것은, 정렬된 데이터구조가 배열만 있는것이 아니다.
js 에 그냥 내장되어있는 구조일 뿐이다.

정렬된 데이터가 필요할때 배열을 사용할수 있지만, 성능을 희생해야 할수 있다.
특히, 입력과 제거를 할때 그렇다.

추가 ( insertion ) - 유동적
제거 ( removal ) - 유동적
탐색 ( searching ) - O(N)
접근 ( access ) - O(1)

접근은 arr[2] 와 같이 인덱스로 바로 접근하는것을 이야기한다
추가와 제거는 '어디에' 하는지에 따라 시간이 유동적이다.

맨 마지막에 요소를 하나 추가하는, push() 같은 경우
배열끝에 데이터를 추가하고, 인덱스를 부여하면 객체에 추가하는것과 다를게 없다.
따라서 이런경우는 상수 시간이다.

문제는 배열 앞에 추가할때이다.
기존 요소들의 인덱스가 있기때문에, 맨앞에 들어올경우 인덱스가 엉망이 되기 때문.
따라서 하나를 추가하는데 모든 요소의 인덱스를 변경해야하느 것이다.
그래서 이런 경우는 O(n) 선형 시간이다.

앞에서 제거하는것도 같은 경우로 O(n) 선형 시간이다.

그래서 빈 배열일 경우를 제외하고 push, pop 은 항상 shift 와 unshift 보다 빠르다.

- 배열 메서드

대부분 생각과 비슷하게 작동하고 O(n) 선형 시간이다, concat 또한 O(n) 이다.
concat 은 배열을 합쳐 주는작업 으로, 결합할 배열의 크기가 클수록 끝에 붙일 배열 크기만큼 늘어난다.
slice 는 내부적으로 copy 하기 때문에, 이역시 배열의 크기만큼 작업시간이 늘어난다.
splice 는 배열에 추가, 삭제, 교체 등을 하는데, 이 역시 맨 마지막에서 작업하지 않는이상 O(n) 선형시간 이다.
sort - O(n\*logn)
